{
  "_args": [
    [
      {
        "raw": "react-native-fetch-blob",
        "scope": null,
        "escapedName": "react-native-fetch-blob",
        "name": "react-native-fetch-blob",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/ericho/Desktop/workspace/evurs-dev"
    ]
  ],
  "_from": "react-native-fetch-blob@latest",
  "_id": "react-native-fetch-blob@0.10.8",
  "_inCache": true,
  "_location": "/react-native-fetch-blob",
  "_nodeVersion": "6.3.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-native-fetch-blob-0.10.8.tgz_1501724425754_0.9977224466856569"
  },
  "_npmUser": {
    "name": "suzuri04x2",
    "email": "xeiyan@gmail.com"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {
    "fs.realpath": "1.0.0",
    "inflight": "1.0.6",
    "inherits": "2.0.3",
    "minimatch": "3.0.4",
    "once": "1.4.0",
    "path-is-absolute": "1.0.1"
  },
  "_requested": {
    "raw": "react-native-fetch-blob",
    "scope": null,
    "escapedName": "react-native-fetch-blob",
    "name": "react-native-fetch-blob",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-native-fetch-blob/-/react-native-fetch-blob-0.10.8.tgz",
  "_shasum": "4fc256abae0cb5f10e7c41f28c11b3ff330d72a9",
  "_shrinkwrap": null,
  "_spec": "react-native-fetch-blob",
  "_where": "/Users/ericho/Desktop/workspace/evurs-dev",
  "author": {
    "name": "wkh237",
    "email": "xeiyan@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/wkh237/react-native-fetch-blob/issues"
  },
  "contributors": [
    {
      "name": "Ben",
      "email": "benhsieh@catchplay.com"
    },
    {}
  ],
  "dependencies": {
    "base-64": "0.1.0",
    "glob": "7.0.6"
  },
  "description": "A module provides upload, download, and files access API. Supports file stream read/write for process large files.",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "4fc256abae0cb5f10e7c41f28c11b3ff330d72a9",
    "tarball": "https://registry.npmjs.org/react-native-fetch-blob/-/react-native-fetch-blob-0.10.8.tgz"
  },
  "homepage": "https://github.com/wkh237/react-native-fetch-blob#readme",
  "keywords": [
    "react-native",
    "fetch",
    "blob",
    "fs",
    "upload",
    "file",
    "download",
    "filestream",
    "image header"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "suzuri04x2",
      "email": "xeiyan@gmail.com"
    }
  ],
  "name": "react-native-fetch-blob",
  "optionalDependencies": {},
  "readme": "# react-native-fetch-blob\n[![release](https://img.shields.io/github/release/wkh237/react-native-fetch-blob.svg?style=flat-square)](https://github.com/wkh237/react-native-fetch-blob/releases) [![npm](https://img.shields.io/npm/v/react-native-fetch-blob.svg?style=flat-square)](https://www.npmjs.com/package/react-native-fetch-blob) ![](https://img.shields.io/badge/PR-Welcome-brightgreen.svg?style=flat-square) [![](https://img.shields.io/badge/Wiki-Public-brightgreen.svg?style=flat-square)](https://github.com/wkh237/react-native-fetch-blob/wiki) [![npm](https://img.shields.io/npm/l/react-native-fetch-blob.svg?maxAge=2592000&style=flat-square)]()\n\n\nA project committed to making file access and data transfer easier and more efficient for React Native developers.\n> For Firebase Storage solution, please upgrade to the latest version for the best compatibility.\n\n## Features\n- Transfer data directly from/to storage without BASE64 bridging\n- File API supports regular files, Asset files, and CameraRoll files\n- Native-to-native file manipulation API, reduce JS bridging performance loss\n- File stream support for dealing with large file\n- Blob, File, XMLHttpRequest polyfills that make browser-based library available in RN (experimental)\n- JSON stream supported base on [Oboe.js](https://github.com/jimhigson/oboe.js/) @jimhigson\n\n## TOC (visit [Wiki](https://github.com/wkh237/react-native-fetch-blob/wiki) to get the complete documentation)\n* [About](#user-content-about)\n* [Installation](#user-content-installation)\n* [HTTP Data Transfer](#user-content-http-data-transfer)\n * [Regular Request](#user-content-regular-request)\n * [Download file](#user-content-download-example--fetch-files-that-needs-authorization-token)\n * [Upload file](#user-content-upload-example--dropbox-files-upload-api)\n * [Multipart/form upload](#user-content-multipartform-data-example--post-form-data-with-file-and-data)\n * [Upload/Download progress](#user-content-uploaddownload-progress)\n * [Cancel HTTP request](#user-content-cancel-request)\n * [Android Media Scanner, and Download Manager Support](#user-content-android-media-scanner-and-download-manager-support)\n * [Self-Signed SSL Server](#user-content-self-signed-ssl-server)\n * [Transfer Encoding](#user-content-transfer-encoding)\n * [Drop-in Fetch Replacement](#user-content-drop-in-fetch-replacement)\n* [File System](#user-content-file-system)\n * [File access](#user-content-file-access)\n * [File stream](#user-content-file-stream)\n * [Manage cached files](#user-content-cache-file-management)\n* [Web API Polyfills](#user-content-web-api-polyfills)\n* [Performance Tips](#user-content-performance-tips)\n* [API References](https://github.com/wkh237/react-native-fetch-blob/wiki/Fetch-API)\n* [Caveats](#user-content-caveats)\n* [Development](#user-content-development)\n\n## About\n\nThis project was started in the cause of solving issue [facebook/react-native#854](https://github.com/facebook/react-native/issues/854), React Native's lacks of `Blob` implementation which results into problems when transferring binary data. \n\nIt is committed to making file access and transfer easier and more efficient for React Native developers. We've implemented highly customizable filesystem and network module which plays well together. For example, developers can upload and download data directly from/to storage, which is more efficient, especially for large files. The file system supports file stream, so you don't have to worry about OOM problem when accessing large files.\n\nIn `0.8.0` we introduced experimental Web API polyfills that make it possible to use browser-based libraries in React Native, such as, [FireBase JS SDK](https://github.com/wkh237/rn-firebase-storage-upload-sample)\n\n\n## Installation\n\nInstall package from npm\n\n```sh\nnpm install --save react-native-fetch-blob\n```\n\nOr if using CocoaPods, add the pod to your `Podfile`\n\n```\npod 'react-native-fetch-blob',\n    :path => '../node_modules/react-native-fetch-blob'\n```\n\nAfter `0.10.3` you can install this package directly from Github \n\n```sh\n# replace <branch_name> with any one of the branches\nnpm install --save github:wkh237/react-native-fetch-blob-package#<branch_name>\n```\n**Automatically Link Native Modules**\n\nFor 0.29.2+ projects, simply link native packages via the following command (note: rnpm has been merged into react-native)\n\n```\nreact-native link\n```\n\nAs for projects < 0.29 you need `rnpm` to link native packages\n\n```sh\nrnpm link\n```\n\nOptionally, use the following command to add Android permissions to `AndroidManifest.xml` automatically\n\n```sh\nRNFB_ANDROID_PERMISSIONS=true react-native link\n```\n\npre 0.29 projects\n\n```sh\nRNFB_ANDROID_PERMISSIONS=true rnpm link\n```\n\nThe link script might not take effect if you have non-default project structure, please visit [the wiki](https://github.com/wkh237/react-native-fetch-blob/wiki/Manually-Link-Package) to link the package manually.\n\n**Grant Permission to External storage for Android 5.0 or lower**\n\nThe mechanism for granting Android permissions has slightly different since Android 6.0 released, please refer to [Official Document](https://developer.android.com/training/permissions/requesting.html).\n\nIf you're going to access external storage (say, SD card storage) for `Android 5.0` (or lower) devices, you might have to add the following line to `AndroidManifest.xml`.\n\n```diff\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.rnfetchblobtest\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/>\n+   <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />                                               \n+   <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />                                              \n\n    ...\n\n```\n\nAlso, if you're going to use `Android Download Manager` you have to add this to `AndroidManifest.xml`\n\n```diff\n    <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n+           <action android:name=\"android.intent.action.DOWNLOAD_COMPLETE\"/>                          \n    </intent-filter>\n```\n\n**Grant Access Permission for Android 6.0**\n\nBeginning in Android 6.0 (API level 23), users grant permissions to apps while the app is running, not when they install the app. So adding permissions in `AndroidManifest.xml` won't work for Android 6.0+ devices. To grant permissions in runtime, you might use [PermissionAndroid API](https://facebook.github.io/react-native/docs/permissionsandroid.html).\n\n## Usage\n\nES6\n\nThe module uses ES6 style export statement, simply use `import` to load the module.\n\n```js\nimport RNFetchBlob from 'react-native-fetch-blob'\n```\n\nES5\n\nIf you're using ES5 require statement to load the module, please add `default`. See [here](https://github.com/wkh237/react-native-fetch-blob/wiki/Trouble-Shooting#rnfetchblobfetch-is-not-a-function) for more detail.\n\n```\nvar RNFetchBlob = require('react-native-fetch-blob').default\n```\n\n## HTTP Data Transfer\n\n\n### Regular Request\n\nAfter `0.8.0` react-native-fetch-blob automatically decides how to send the body by checking its type and `Content-Type` in the header. The rule is described in the following diagram\n\n<img src=\"img/RNFB-Flow-hd.png\" style=\"width : 90%\" />\n\nTo sum up:\n\n- To send a form data, the `Content-Type` header does not matter. When the body is an `Array` we will set proper content type for you.\n- To send binary data, you have two choices, use BASE64 encoded string or path points to a file contains the body.\n - If the `Content-Type` containing substring`;BASE64` or `application/octet` the given body will be considered as a BASE64 encoded data which will be decoded to binary data as the request body.   \n - Otherwise, if a string starts with `RNFetchBlob-file://` (which can simply be done by `RNFetchBlob.wrap(PATH_TO_THE_FILE)`), it will try to find the data from the URI string after `RNFetchBlob-file://` and use it as the request body.\n- To send the body as-is, simply use a `Content-Type` header not containing `;BASE64` or `application/octet`.\n\n> It is Worth to mentioning that the HTTP request uses cache by default, if you're going to disable it simply add a Cache-Control header `'Cache-Control' : 'no-store'`\n\n> After 0.9.4, we disabled `Chunked` transfer encoding by default, if you're going to use it, you should explicitly set header `Transfer-Encoding` to `Chunked`.\n\n### Download example: Fetch files that need authorization token\n\nMost simple way is download to memory and stored as BASE64 encoded string, this is handy when the response data is small.\n\n```js\n\n// send http request in a new thread (using native code)\nRNFetchBlob.fetch('GET', 'http://www.example.com/images/img1.png', {\n    Authorization : 'Bearer access-token...',\n    // more headers  ..\n  })\n  // when response status code is 200\n  .then((res) => {\n    // the conversion is done in native code\n    let base64Str = res.base64()\n    // the following conversions are done in js, it's SYNC\n    let text = res.text()\n    let json = res.json()\n\n  })\n  // Status code is not 200\n  .catch((errorMessage, statusCode) => {\n    // error handling\n  })\n```\n\n### Download to storage directly\n\nIf the response data is large, that would be a bad idea to convert it into BASE64 string. A better solution is streaming the response directly into a file, simply add a `fileCache` option to config, and set it to `true`. This will make incoming response data stored in a temporary path **without** any file extension.\n\n**These files won't be removed automatically, please refer to [Cache File Management](#user-content-cache-file-management)**\n\n```js\nRNFetchBlob\n  .config({\n    // add this option that makes response data to be stored as a file,\n    // this is much more performant.\n    fileCache : true,\n  })\n  .fetch('GET', 'http://www.example.com/file/example.zip', {\n    //some headers ..\n  })\n  .then((res) => {\n    // the temp file path\n    console.log('The file saved to ', res.path())\n  })\n```\n\n**Set Temp File Extension**\n\nSometimes you might need a file extension for some reason. For example, when using file path as the source of `Image` component, the path should end with something like .png or .jpg, you can do this by add `appendExt` option to `config`.\n\n```js\nRNFetchBlob\n  .config({\n    fileCache : true,\n    // by adding this option, the temp files will have a file extension\n    appendExt : 'png'\n  })\n  .fetch('GET', 'http://www.example.com/file/example.zip', {\n    //some headers ..\n  })\n  .then((res) => {\n    // the temp file path with file extension `png`\n    console.log('The file saved to ', res.path())\n    // Beware that when using a file path as Image source on Android,\n    // you must prepend \"file://\"\" before the file path\n    imageView = <Image source={{ uri : Platform.OS === 'android' ? 'file://' + res.path()  : '' + res.path() }}/>\n  })\n```\n\n**Use Specific File Path**\n\nIf you prefer a particular file path rather than randomly generated one, you can use `path` option. We've added [several  constants](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#dirs) in v0.5.0 which represents commonly used directories.\n\n```js\nlet dirs = RNFetchBlob.fs.dirs\nRNFetchBlob\n.config({\n  // response data will be saved to this path if it has access right.\n  path : dirs.DocumentDir + '/path-to-file.anything'\n})\n.fetch('GET', 'http://www.example.com/file/example.zip', {\n  //some headers ..\n})\n.then((res) => {\n  // the path should be dirs.DocumentDir + 'path-to-file.anything'\n  console.log('The file saved to ', res.path())\n})\n```\n\n**These files won't be removed automatically, please refer to [Cache File Management](#user-content-cache-file-management)**\n\n####  Upload example : Dropbox [files-upload](https://www.dropbox.com/developers/documentation/http/documentation#files-upload) API\n\n`react-native-fetch-blob` will convert the base64 string in `body` to binary format using native API, this process is done in a separated thread so that it won't block your GUI.\n\n```js\n\nRNFetchBlob.fetch('POST', 'https://content.dropboxapi.com/2/files/upload', {\n    Authorization : \"Bearer access-token...\",\n    'Dropbox-API-Arg': JSON.stringify({\n      path : '/img-from-react-native.png',\n      mode : 'add',\n      autorename : true,\n      mute : false\n    }),\n    'Content-Type' : 'application/octet-stream',\n    // here's the body you're going to send, should be a BASE64 encoded string\n    // (you can use \"base64\"(refer to the library 'mathiasbynens/base64') APIs to make one).\n    // The data will be converted to \"byte array\"(say, blob) before request sent.  \n  }, base64ImageString)\n  .then((res) => {\n    console.log(res.text())\n  })\n  .catch((err) => {\n    // error handling ..\n  })\n```\n\n### Upload a file from storage\n\nIf you're going to use a `file` as request body, just wrap the path with `wrap` API.\n\n```js\nRNFetchBlob.fetch('POST', 'https://content.dropboxapi.com/2/files/upload', {\n    // dropbox upload headers\n    Authorization : \"Bearer access-token...\",\n    'Dropbox-API-Arg': JSON.stringify({\n      path : '/img-from-react-native.png',\n      mode : 'add',\n      autorename : true,\n      mute : false\n    }),\n    'Content-Type' : 'application/octet-stream',\n    // Change BASE64 encoded data to a file path with prefix `RNFetchBlob-file://`.\n    // Or simply wrap the file path with RNFetchBlob.wrap().\n  }, RNFetchBlob.wrap(PATH_TO_THE_FILE))\n  .then((res) => {\n    console.log(res.text())\n  })\n  .catch((err) => {\n    // error handling ..\n  })\n```\n\n### Multipart/form-data example: Post form data with file and data\n\nIn `version >= 0.3.0` you can also post files with form data, just put an array in `body`, with elements have property `name`, `data`, and `filename`(optional).\n\nElements have property `filename` will be transformed into binary format, otherwise, it turns into utf8 string.\n\n```js\n\n  RNFetchBlob.fetch('POST', 'http://www.example.com/upload-form', {\n    Authorization : \"Bearer access-token\",\n    otherHeader : \"foo\",\n    'Content-Type' : 'multipart/form-data',\n  }, [\n    // element with property `filename` will be transformed into `file` in form data\n    { name : 'avatar', filename : 'avatar.png', data: binaryDataInBase64},\n    // custom content type\n    { name : 'avatar-png', filename : 'avatar-png.png', type:'image/png', data: binaryDataInBase64},\n    // part file from storage\n    { name : 'avatar-foo', filename : 'avatar-foo.png', type:'image/foo', data: RNFetchBlob.wrap(path_to_a_file)},\n    // elements without property `filename` will be sent as plain text\n    { name : 'name', data : 'user'},\n    { name : 'info', data : JSON.stringify({\n      mail : 'example@example.com',\n      tel : '12345678'\n    })},\n  ]).then((resp) => {\n    // ...\n  }).catch((err) => {\n    // ...\n  })\n```\n\nWhat if you want to append a file to form data? Just like [upload a file from storage](#user-content-upload-a-file-from-storage) example, wrap `data` by `wrap` API (this feature is only available for `version >= v0.5.0`). On version >= `0.6.2`, it is possible to set custom MIME type when appending a file to form data. But keep in mind when the file is large it's likely to crash your app. Please consider use other strategy (see [#94](https://github.com/wkh237/react-native-fetch-blob/issues/94)).\n\n```js\n\n  RNFetchBlob.fetch('POST', 'http://www.example.com/upload-form', {\n    Authorization : \"Bearer access-token\",\n    otherHeader : \"foo\",\n    // this is required, otherwise it won't be process as a multipart/form-data request\n    'Content-Type' : 'multipart/form-data',\n  }, [\n    // append field data from file path\n    {\n      name : 'avatar',\n      filename : 'avatar.png',\n      // Change BASE64 encoded data to a file path with prefix `RNFetchBlob-file://`.\n      // Or simply wrap the file path with RNFetchBlob.wrap().\n      data: RNFetchBlob.wrap(PATH_TO_THE_FILE)\n    },\n    {\n      name : 'ringtone',\n      filename : 'ring.mp3',\n      // use custom MIME type\n      type : 'application/mp3',\n      // upload a file from asset is also possible in version >= 0.6.2\n      data : RNFetchBlob.wrap(RNFetchBlob.fs.asset('default-ringtone.mp3'))\n    }\n    // elements without property `filename` will be sent as plain text\n    { name : 'name', data : 'user'},\n    { name : 'info', data : JSON.stringify({\n      mail : 'example@example.com',\n      tel : '12345678'\n    })},\n  ]).then((resp) => {\n    // ...\n  }).catch((err) => {\n    // ...\n  })\n```\n\n### Upload/Download progress\n\nIn `version >= 0.4.2` it is possible to know the upload/download progress. After `0.7.0` IOS and Android upload progress are also supported.\n\n```js\n  RNFetchBlob.fetch('POST', 'http://www.example.com/upload', {\n      //... some headers,\n      'Content-Type' : 'octet-stream'\n    }, base64DataString)\n    // listen to upload progress event\n    .uploadProgress((written, total) => {\n        console.log('uploaded', written / total)\n    })\n    // listen to download progress event\n    .progress((received, total) => {\n        console.log('progress', received / total)\n    })\n    .then((resp) => {\n      // ...\n    })\n    .catch((err) => {\n      // ...\n    })\n```\n\nIn `0.9.6`, you can specify an object as the first argument which contains `count` and `interval`, to the frequency of progress event (this will be done in the native context a  reduce RCT bridge overhead). Notice that `count` argument will not work if the server does not provide response content length.\n\n\n```js\n  RNFetchBlob.fetch('POST', 'http://www.example.com/upload', {\n      //... some headers,\n      'Content-Type' : 'octet-stream'\n    }, base64DataString)\n    // listen to upload progress event, emit every 250ms\n    .uploadProgress({ interval : 250 },(written, total) => {\n        console.log('uploaded', written / total)\n    })\n    // listen to download progress event, every 10%\n    .progress({ count : 10 }, (received, total) => {\n        console.log('progress', received / total)\n    })\n    .then((resp) => {\n      // ...\n    })\n    .catch((err) => {\n      // ...\n    })\n```\n\n### Cancel Request\n\nAfter `0.7.0` it is possible to cancel an HTTP request. Upon cancellation, it throws a promise rejection, be sure to catch it.\n\n```js\nlet task = RNFetchBlob.fetch('GET', 'http://example.com/file/1')\n\ntask.then(() => { ... })\n    // handle request cancelled rejection\n    .catch((err) => {\n        console.log(err)\n    })\n// cancel the request, the callback function is optional\ntask.cancel((err) => { ... })\n\n```\n\n### Drop-in Fetch Replacement\n\n0.9.0\n\nIf you have existing code that uses `whatwg-fetch`(the official **fetch**), it's not necessary to replace them with `RNFetchblob.fetch`, you can simply use our **Fetch Replacement**. The difference between Official them is official fetch uses [whatwg-fetch](https://github.com/github/fetch) which wraps XMLHttpRequest polyfill under the hood. It's a great library for web developers, but does not play very well with RN. Our implementation is simply a wrapper of our `fetch` and `fs` APIs, so you can access all the features we provided.\n\n[See document and examples](https://github.com/wkh237/react-native-fetch-blob/wiki/Fetch-API#fetch-replacement)\n\n### Android Media Scanner, and Download Manager Support\n\nIf you want to make a file in `External Storage` becomes visible in Picture, Downloads, or other built-in apps, you will have to use `Media Scanner` or `Download Manager`.\n\n**Media Scanner**\n\nMedia scanner scans the file and categorizes by given MIME type, if MIME type not specified, it will try to resolve the file using its file extension.\n\n```js\n\nRNFetchBlob\n    .config({\n        // DCIMDir is in external storage\n        path : dirs.DCIMDir + '/music.mp3'\n    })\n    .fetch('GET', 'http://example.com/music.mp3')\n    .then((res) => RNFetchBlob.fs.scanFile([ { path : res.path(), mime : 'audio/mpeg' } ]))\n    .then(() => {\n        // scan file success\n    })\n    .catch((err) => {\n        // scan file error\n    })\n```\n\n**Download Manager**\n\nWhen downloading large files on Android it is recommended to use `Download Manager`, it supports a lot of native features like the progress bar, and notification, also the download task will be handled by OS, and more efficient.\n\n<img src=\"img/download-manager.png\" width=\"256\">\n\nWhen using DownloadManager, `fileCache` and `path` properties in `config` will not take effect, because Android DownloadManager can only store files to external storage, also notice that Download Manager can only support `GET` method, which means the request body will be ignored.\n\nWhen download complete, DownloadManager will generate a file path so that you can deal with it.\n\n```js\nRNFetchBlob\n    .config({\n        addAndroidDownloads : {\n            useDownloadManager : true, // <-- this is the only thing required\n            // Optional, override notification setting (default to true)\n            notification : false,\n            // Optional, but recommended since android DownloadManager will fail when\n            // the url does not contains a file extension, by default the mime type will be text/plain\n            mime : 'text/plain',\n            description : 'File downloaded by download manager.'\n        }\n    })\n    .fetch('GET', 'http://example.com/file/somefile')\n    .then((resp) => {\n      // the path of downloaded file\n      resp.path()\n    })\n```\n\nYour app might not have right to remove/change the file created by Download Manager, therefore you might need to [set custom location to the download task](https://github.com/wkh237/react-native-fetch-blob/issues/236).\n\n**Download Notification and Visibility in Download App (Android Only)**\n\n<img src=\"img/android-notification1.png\" width=\"256\">\n<img src=\"img/android-notification2.png\" width=\"256\">\n\n\nIf you need to display a notification upon the file is downloaded to storage (as the above) or make the downloaded file visible in \"Downloads\" app. You have to add some options to `config`.\n\n```js\nRNFetchBlob.config({\n  fileCache : true,\n  // android only options, these options be a no-op on IOS\n  addAndroidDownloads : {\n    // Show notification when response data transmitted\n    notification : true,\n    // Title of download notification\n    title : 'Great ! Download Success ! :O ',\n    // File description (not notification description)\n    description : 'An image file.',\n    mime : 'image/png',\n    // Make the file scannable  by media scanner\n    mediaScannable : true,\n  }\n})\n.fetch('GET', 'http://example.com/image1.png')\n.then(...)\n```\n\n**Open Downloaded File with Intent**\n\nThis is a new feature added in `0.9.0` if you're going to open a file path using official [Linking](https://facebook.github.io/react-native/docs/linking.html) API that might not work as expected, also, if you're going to install an APK in `Downloads` app, that will not function too. As an alternative, you can try `actionViewIntent` API, which will send an ACTION_VIEW intent for you which uses the given `MIME` type.\n\nDownload and install an APK programmatically\n\n```js\n\nconst android = RNFetchBlob.android\n\nRNFetchBlob.config({\n    addAndroidDownloads : {\n      useDownloadManager : true,\n      title : 'awesome.apk',\n      description : 'An APK that will be installed',\n      mime : 'application/vnd.android.package-archive',\n      mediaScannable : true,\n      notification : true,\n    }\n  })\n  .fetch('GET', `http://www.example.com/awesome.apk`)\n  .then((res) => {\n      android.actionViewIntent(res.path(), 'application/vnd.android.package-archive')\n  })\n```\n\nOr show an image in image viewer\n\n```js\n      android.actionViewIntent(PATH_OF_IMG, 'image/png')\n```\n\n## File System\n\n### File Access\n\nFile access APIs were made when developing `v0.5.0`, which helping us write tests, and was not planned to be a part of this module. However, we realized that it's hard to find a great solution to manage cached files, everyone who uses this module may need these APIs for their cases.\n\nBefore start using file APIs, we recommend read [Differences between File Source](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#differences-between-file-source) first.\n\nFile Access APIs\n- [asset (0.6.2)](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#assetfilenamestringstring)\n- [dirs](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#dirs)\n- [createFile](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#createfilepath-data-encodingpromise)\n- [writeFile (0.6.0)](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#writefilepathstring-contentstring--array-encodingstring-appendbooleanpromise)\n- [appendFile (0.6.0) ](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#appendfilepathstring-contentstring--array-encodingstringpromise)\n- [readFile (0.6.0)](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#readfilepath-encodingpromise)\n- [readStream](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#readstreampath-encoding-buffersizepromise)\n- [writeStream](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#writestreampathstring-encodingstring-appendbooleanpromise)\n- [unlink](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#unlinkpathstringpromise)\n- [mkdir](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#mkdirpathstringpromise)\n- [ls](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#lspathstringpromise)\n- [mv](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#mvfromstring-tostringpromise)\n- [cp](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#cpsrcstring-deststringpromise)\n- [exists](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#existspathstringpromise)\n- [isDir](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#isdirpathstringpromise)\n- [stat](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#statpathstringpromise)\n- [lstat](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#lstatpathstringpromise)\n- [scanFile (Android only)](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API#scanfilepathstringpromise-androi-only)\n\nSee [File API](https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API) for more information\n\n### File Stream\n\nIn `v0.5.0` we've added  `writeStream` and `readStream`, which allows your app read/write data from the file path. This API creates a file stream, rather than convert entire data into BASE64 encoded string. It's handy when processing **large files**.\n\nWhen calling `readStream` method, you have to `open` the stream, and start to read data. When the file is large, consider using an appropriate `bufferSize` and `interval` to reduce the native event dispatching overhead (see [Performance Tips](#user-content-performance-tips))\n\n> The file stream event has a default throttle(10ms) and buffer size which preventing it cause too much overhead to main thread, yo can also [tweak these values](#user-content-performance-tips).\n\n```js\nlet data = ''\nRNFetchBlob.fs.readStream(\n    // file path\n    PATH_TO_THE_FILE,\n    // encoding, should be one of `base64`, `utf8`, `ascii`\n    'base64',\n    // (optional) buffer size, default to 4096 (4095 for BASE64 encoded data)\n    // when reading file in BASE64 encoding, buffer size must be multiples of 3.\n    4095)\n.then((ifstream) => {\n    ifstream.open()\n    ifstream.onData((chunk) => {\n      // when encoding is `ascii`, chunk will be an array contains numbers\n      // otherwise it will be a string\n      data += chunk\n    })\n    ifstream.onError((err) => {\n      console.log('oops', err)\n    })\n    ifstream.onEnd(() => {  \n      <Image source={{ uri : 'data:image/png,base64' + data }}\n    })\n})\n```\n\nWhen using `writeStream`, the stream object becomes writable, and you can then perform operations like `write` and `close`.\n\n```js\nRNFetchBlob.fs.writeStream(\n    PATH_TO_FILE,\n    // encoding, should be one of `base64`, `utf8`, `ascii`\n    'utf8',\n    // should data append to existing content ?\n    true)\n.then((ofstream) => {\n    ofstream.write('foo')\n    ofstream.write('bar')\n    ofstream.close()\n})\n\n```\n\n### Cache File Management\n\nWhen using `fileCache` or `path` options along with `fetch` API, response data will automatically store into the file system. The files will **NOT** removed unless you `unlink` it. There're several ways to remove the files\n\n```js\n\n  // remove file using RNFetchblobResponse.flush() object method\n  RNFetchblob.config({\n      fileCache : true\n    })\n    .fetch('GET', 'http://example.com/download/file')\n    .then((res) => {\n      // remove cached file from storage\n      res.flush()\n    })\n\n  // remove file by specifying a path\n  RNFetchBlob.fs.unlink('some-file-path').then(() => {\n    // ...\n  })\n\n```\n\nYou can also group requests by using `session` API and use `dispose` to remove them all when needed.\n\n```js\n\n  RNFetchblob.config({\n    fileCache : true\n  })\n  .fetch('GET', 'http://example.com/download/file')\n  .then((res) => {\n    // set session of a response\n    res.session('foo')\n  })  \n\n  RNFetchblob.config({\n    // you can also set session beforehand\n    session : 'foo'\n    fileCache : true\n  })\n  .fetch('GET', 'http://example.com/download/file')\n  .then((res) => {\n    // ...\n  })  \n\n  // or put an existing file path to the session\n  RNFetchBlob.session('foo').add('some-file-path')\n  // remove a file path from the session\n  RNFetchBlob.session('foo').remove('some-file-path')\n  // list paths of a session\n  RNFetchBlob.session('foo').list()\n  // remove all files in a session\n  RNFetchBlob.session('foo').dispose().then(() => { ... })\n\n```\n\n### Transfer Encoding\n\nAfter `0.9.4`, the `Chunked` transfer encoding is disabled by default due to some service provider may not support chunked transfer. To enable it, set `Transfer-Encoding` header to `Chunked`.\n\n```js\nRNFetchBlob.fetch('POST', 'http://example.com/upload', { 'Transfer-Encoding' : 'Chunked' }, bodyData)\n```\n\n### Self-Signed SSL Server\n\nBy default, react-native-fetch-blob does NOT allow connection to unknown certification provider since it's dangerous. To connect a server with self-signed certification, you need to add `trusty` to `config` explicitly. This function is available for version >= `0.5.3`\n\n```js\nRNFetchBlob.config({\n  trusty : true\n})\n.then('GET', 'https://mysite.com')\n.then((resp) => {\n  // ...\n})\n```\n\n## Web API Polyfills\n\nAfter `0.8.0` we've made some [Web API polyfills](https://github.com/wkh237/react-native-fetch-blob/wiki/Web-API-Polyfills-(experimental)) that makes some browser-based library available in RN.\n\n- Blob\n- XMLHttpRequest (Use our implementation if you're going to use it with Blob)\n\nHere's a [sample app](https://github.com/wkh237/rn-firebase-storage-upload-sample) that uses polyfills to upload files to FireBase.\n\n## Performance Tips\n\n**Read Stream and Progress Event Overhead**\n\nIf the process seems to block JS thread when file is large when reading data via `fs.readStream`.  It might because the default buffer size is quite small (4kb) which result in a lot of events triggered from JS thread. Try to increase the buffer size (for example 100kb = 102400) and set a larger interval (available for 0.9.4+, the default value is 10ms) to limit the frequency.\n\n**Reduce RCT Bridge and BASE64 Overhead**\n\nReact Native connects JS and Native context by passing JSON around React Native bridge, and there will be an overhead to convert data before they sent to each side. When data is large, this will be quite a performance impact to your app. It's recommended to use file storage instead of BASE64 if possible.The following chart shows how much faster when loading data from storage than BASE64 encoded string on iPhone 6.\n\n<img src=\"img/performance_1.png\" style=\"width : 100%\"/>\n\n**ASCII Encoding has /terrible Performance**\n\nDue to the [lack of typed array implementation in JavascriptCore, and limitation of React Native structure](https://github.com/facebook/react-native/issues/1424), to convert data to JS byte array spends lot of time. Use it only when needed, the following chart shows how much time it takes when reading a file with different encoding.\n\n<img src=\"img/performance_encoding.png\" style=\"width : 100%\"/>\n\n**Concat and Replacing Files**\n\nIf you're going to concatenate files, you don't have to read the data to JS context anymore! In `0.8.0` we introduced new encoding `uri` for writeFile and appendFile API, which make it possible to handle the whole process in native.\n\n<img src=\"img/performance_f2f.png\" style=\"width : 100%\"/>\n\n## Caveats\n\n* This library does not urlencode unicode characters in URL automatically, see [#146](https://github.com/wkh237/react-native-fetch-blob/issues/146).\n* When you create a `Blob` ,  from an existing file, the file **WILL BE REMOVED** if you `close` the blob.\n* If you replaced `window.XMLHttpRequest` for some reason (e.g. make Firebase SDK work), it will also affect how official `fetch` works (basically it should work just fine).\n* When file stream and upload/download progress event slow down your app, consider an upgrade to `0.9.6+`, use [additional arguments](https://github.com/wkh237/react-native-fetch-blob/wiki/Fetch-API#fetchprogressconfig-eventlistenerpromisernfetchblobresponse) to limit its frequency.\n* When passing a file path to the library, remove `file://` prefix.\n\nwhen you got a problem, have a look at [Trouble Shooting](https://github.com/wkh237/react-native-fetch-blob/wiki/Trouble-Shooting) or [issues labeled Trouble Shooting](https://github.com/wkh237/react-native-fetch-blob/issues?utf8=âœ“&q=label:%22trouble%20shooting%22%20), there'd be some helpful information.\n\n## Changes\n\nSee [release notes](https://github.com/wkh237/react-native-fetch-blob/releases)\n\n### Development\n\nIf you're interested in hacking this module, check our [development guide](https://github.com/wkh237/react-native-fetch-blob/wiki/Home), there might be some helpful information.\nPlease feel free to make a PR or file an issue.\n",
  "readmeFilename": "README.md",
  "repository": {
    "url": "git+https://github.com/wkh237/react-native-fetch-blob.git"
  },
  "rnpm": {
    "commands": {
      "prelink": "node ./node_modules/react-native-fetch-blob/scripts/prelink.js"
    }
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "0.10.8"
}
